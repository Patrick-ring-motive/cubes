<svg width="600" height="600"
     viewBox="-100 -100 700 700"
     xmlns="http://www.w3.org/2000/svg">

  <style>
    .face {
      fill: #8fb3a2;
      stroke-width: 1;
      stroke-linejoin: round;
      vector-effect: non-scaling-stroke;
      cursor: pointer;
    }
  </style>

  <defs id="filters"></defs>

  <script><![CDATA[
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.currentScript.parentNode;
    const defs = document.getElementById("filters");

    const size = 5;
    const tileW = 64;
    const tileH = 32;
    const levelH = 32;
    const originX = 250;
    const originY = 50;

    const cubes = new Set();
    for (let z=0; z<size; z++)
      for (let y=0; y<size; y++)
        for (let x=0; x<size; x++)
          cubes.add(`${x},${y},${z}`);

    const hasCube = (x,y,z) => cubes.has(`${x},${y},${z}`);

    function faceFilter(x,y,z,brightness) {
      const id = `f-${x}-${y}-${z}-${brightness}`;
      if (document.getElementById(id)) return id;

      const f = document.createElementNS(svgNS,"filter");
      f.id = id;

      const sat = document.createElementNS(svgNS,"feColorMatrix");
      sat.setAttribute("type","saturate");
      sat.setAttribute("values",(1 + x*0.05).toFixed(3));
      sat.setAttribute("result","s");
      f.appendChild(sat);

      const ct = document.createElementNS(svgNS,"feComponentTransfer");
      ct.setAttribute("in","s");
      ct.setAttribute("result","c");
      ["R","G","B"].forEach(ch=>{
        const fn = document.createElementNS(svgNS,"feFunc"+ch);
        fn.setAttribute("type","linear");
        fn.setAttribute("slope",(1 + y*0.05).toFixed(3));
        ct.appendChild(fn);
      });
      f.appendChild(ct);

      const hue = document.createElementNS(svgNS,"feColorMatrix");
      hue.setAttribute("in","c");
      hue.setAttribute("type","hueRotate");
      hue.setAttribute("values",(z*10).toFixed(1));
      hue.setAttribute("result","h");
      f.appendChild(hue);

      const br = document.createElementNS(svgNS,"feComponentTransfer");
      br.setAttribute("in","h");
      ["R","G","B"].forEach(ch=>{
        const fn = document.createElementNS(svgNS,"feFunc"+ch);
        fn.setAttribute("type","linear");
        fn.setAttribute("slope",brightness);
        br.appendChild(fn);
      });
      f.appendChild(br);

      defs.appendChild(f);
      return id;
    }

    for (let z=0; z<size; z++) {
      for (let y=0; y<size; y++) {
        for (let x=0; x<size; x++) {

          const sx = originX + (x - y) * (tileW/2);
          const sy = originY + (x + y) * (tileH/2) - z*levelH;

          const g = document.createElementNS(svgNS,"g");
          g.setAttribute("transform",`translate(${sx},${sy})`);

          // TOP
          if (!hasCube(x,y,z+1)) {
            const p = document.createElementNS(svgNS,"polygon");
            p.setAttribute("points","64 16,96 32,64 48,32 32");
            p.setAttribute("class","face");
            p.setAttribute("filter",`url(#${faceFilter(x,y,z,1.15)})`);
            p.style.stroke = "black";
            g.appendChild(p);
          }

          // LEFT
          if (!hasCube(x-1,y,z)) {
            const p = document.createElementNS(svgNS,"polygon");
            p.setAttribute("points","32 32,64 48,64 80,32 64");
            p.setAttribute("class","face");
            p.setAttribute("filter",`url(#${faceFilter(x,y,z,0.95)})`);
            p.style.stroke = "black";
            g.appendChild(p);
          }

          // RIGHT
          if (!hasCube(x,y-1,z)) {
            const p = document.createElementNS(svgNS,"polygon");
            p.setAttribute("points","96 32,64 48,64 80,96 64");
            p.setAttribute("class","face");
            p.setAttribute("filter",`url(#${faceFilter(x,y,z,0.8)})`);
            p.style.stroke = "black";
            g.appendChild(p);
          }

          g.addEventListener("click",()=>{
            cubes.delete(`${x},${y},${z}`);
            g.remove();
          });

          svg.appendChild(g);
        }
      }
    }
  ]]></script>
</svg>
