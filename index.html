<svg width="600" height="600" viewBox="-500 -500 1500 1500" xmlns="http://www.w3.org/2000/svg">
<rect width="1000%" height="1000%" fill="skyblue"/>

  <style>
    .face {
      stroke: none;
      cursor: pointer;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.9);
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      font-family: system-ui, sans-serif;
      font-size: 14px;
      z-index: 1000;
    }
    #controls label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    #colorInput {
      width: 100px;
      height: 30px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    #modeToggle {
      width: 100%;
      padding: 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      transition: background-color 0.2s;
    }
    #modeToggle.add {
      background-color: #4CAF50;
      color: white;
    }
    #modeToggle.remove {
      background-color: #f44336;
      color: white;
    }
    .rotate-btn {
      width: 48%;
      padding: 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      background-color: #2196F3;
      color: white;
      margin-top: 5px;
    }
    .rotate-controls {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
    }
    #resetBtn {
      width: 100%;
      padding: 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 14px;
      background-color: #FF9800;
      color: white;
      margin-top: 5px;
    }
  </style>

  <foreignObject x="-200" y="-200" width="300" height="200">
    <div xmlns="http://www.w3.org/1999/xhtml" id="controls">
      <label for="colorInput">Block Color:</label>
      <input type="color" id="colorInput" value="#708000"/>
      <button id="modeToggle" class="add">Mode: Add Blocks</button>
      <div class="rotate-controls">
        <button id="rotateLeft" class="rotate-btn">↺ Rotate Left</button>
        <button id="rotateRight" class="rotate-btn">Rotate Right ↻</button>
      </div>
      <button id="resetBtn">Reset Grid</button>
    </div>
  </foreignObject>

  <defs id="filters">
    <filter id="grain">
      <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" result="noise"/>
      <feColorMatrix in="noise" type="saturate" values="0" result="desaturatedNoise"/>
      <feComponentTransfer in="desaturatedNoise" result="theNoise">
        <feFuncA type="table" tableValues="0 0 0.05 0"/>
      </feComponentTransfer>
      <feBlend in="SourceGraphic" in2="theNoise" mode="multiply"/>
    </filter>
  </defs>

  <script type="application/ecmascript">/*<![CDATA[/**/
    const svgNS = "http://www.w3.org/2000/svg";
    const defs = document.getElementById("filters");
    const svg = document.currentScript.parentNode;
    const colorInput = document.getElementById("colorInput");
    const modeToggle = document.getElementById("modeToggle");
    const rotateLeftBtn = document.getElementById("rotateLeft");
    const rotateRightBtn = document.getElementById("rotateRight");
    const resetBtn = document.getElementById("resetBtn");

    let isAddMode = true;

    // Save state to localStorage
    function saveState() {
      const state = {
        blocks: blockData,
        color: colorInput.value
      };
      localStorage.setItem('dimetricGrid', JSON.stringify(state));
    }

    // Load state from localStorage
    function loadState() {
      const saved = localStorage.getItem('dimetricGrid');
      if (saved) {
        try {
          const state = JSON.parse(saved);
          if (state.blocks && Array.isArray(state.blocks)) {
            // Copy loaded data into blockData
            for (let z = 0; z < size && z < state.blocks.length; z++) {
              for (let y = 0; y < size && y < state.blocks[z].length; y++) {
                for (let x = 0; x < size && x < state.blocks[z][y].length; x++) {
                  blockData[z][y][x] = state.blocks[z][y][x];
                }
              }
            }
          }
          if (state.color) {
            colorInput.value = state.color;
          }
        } catch (e) {
          console.error('Error loading state:', e);
        }
      }
    }

    // Reset grid to initial state
    function resetGrid() {
      for (let z = 0; z < size; z++) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            blockData[z][y][x] = { exists: z === 0, color: "#708000" };
          }
        }
      }
      saveState();
      renderAllBlocks();
    }

    resetBtn.addEventListener("click", () => {
      if (confirm("Reset the grid to its initial state?")) {
        resetGrid();
      }
    });

    // Toggle between add and remove modes
    modeToggle.addEventListener("click", () => {
      isAddMode = !isAddMode;
      if (isAddMode) {
        modeToggle.textContent = "Mode: Add Blocks";
        modeToggle.className = "add";
      } else {
        modeToggle.textContent = "Mode: Remove Blocks";
        modeToggle.className = "remove";
      }
    });

    // Rotate left (counter-clockwise) - rotate data -90 degrees
    rotateLeftBtn.addEventListener("click", () => {
      rotateDataCounterClockwise();
      renderAllBlocks();
      saveState();
    });

    // Rotate right (clockwise) - rotate data +90 degrees
    rotateRightBtn.addEventListener("click", () => {
      rotateDataClockwise();
      renderAllBlocks();
      saveState();
    });

    function rotateDataClockwise() {
      const newBlockData = [];
      for (let z = 0; z < size; z++) {
        newBlockData[z] = [];
        for (let y = 0; y < size; y++) {
          newBlockData[z][y] = [];
          for (let x = 0; x < size; x++) {
            // Clockwise: new[z][y][x] = old[z][size-1-x][y]
            newBlockData[z][y][x] = blockData[z][size - 1 - x][y];
          }
        }
      }
      
      // Copy back
      for (let z = 0; z < size; z++) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            blockData[z][y][x] = newBlockData[z][y][x];
          }
        }
      }
    }

    function rotateDataCounterClockwise() {
      const newBlockData = [];
      for (let z = 0; z < size; z++) {
        newBlockData[z] = [];
        for (let y = 0; y < size; y++) {
          newBlockData[z][y] = [];
          for (let x = 0; x < size; x++) {
            // Counter-clockwise: new[z][y][x] = old[z][x][size-1-y]
            newBlockData[z][y][x] = blockData[z][x][size - 1 - y];
          }
        }
      }
      
      // Copy back
      for (let z = 0; z < size; z++) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            blockData[z][y][x] = newBlockData[z][y][x];
          }
        }
      }
    }

    const size = 10;
    const tileW = 64;
    const tileH = 24;
    const originX = 300;
    const originY = 100;
    const levelHeight = 40;

    const xScale = 0.935;
    const yScale = 0.935;

    // Track blocks in a 3D matrix
    const blockData = [];
    for (let z = 0; z < size; z++) {
      blockData[z] = [];
      for (let y = 0; y < size; y++) {
        blockData[z][y] = [];
        for (let x = 0; x < size; x++) {
          // Only fill the bottom layer (z === 0)
          blockData[z][y][x] = { exists: z === 0, color: "#708000" };
        }
      }
    }

    function renderAllBlocks() {
      // Clear all rendered blocks
      const existingBlocks = svg.querySelectorAll('g[data-block]');
      existingBlocks.forEach(block => block.remove());

      // Render in correct order: back to front, bottom to top
      for (let z = 0; z < size; z++) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const block = blockData[z][y][x];
            if (block.exists) {
              renderBlock(x, y, z, block.color);
            }
          }
        }
      }
    }

    function createFaceFilter(x, y, z, brightness, color) {
      const filterId = `f-${x}-${y}-${z}-${brightness}-${color.replace('#','')}`;
      
      // Check if filter already exists
      if (document.getElementById(filterId)) {
        return filterId;
      }

      const filter = document.createElementNS(svgNS,"filter");
      filter.setAttribute("id", filterId);

      const flood = document.createElementNS(svgNS,"feFlood");
      flood.setAttribute("flood-color", color);
      flood.setAttribute("result","baseColor");
      filter.appendChild(flood);

      const composite1 = document.createElementNS(svgNS,"feComposite");
      composite1.setAttribute("in","baseColor");
      composite1.setAttribute("in2","SourceAlpha");
      composite1.setAttribute("operator","in");
      composite1.setAttribute("result","coloredShape");
      filter.appendChild(composite1);

      const turbulence = document.createElementNS(svgNS,"feTurbulence");
      turbulence.setAttribute("type","turbulence");
      turbulence.setAttribute("baseFrequency","1");
      turbulence.setAttribute("numOctaves","5");
      turbulence.setAttribute("result","noise");
      turbulence.setAttribute("stitchTiles","stitch");
      filter.appendChild(turbulence);

      const sat = document.createElementNS(svgNS,"feColorMatrix");
      sat.setAttribute("in","coloredShape");
      sat.setAttribute("type","saturate");
      sat.setAttribute("values", (1 + x*0.05).toFixed(3));
      sat.setAttribute("result","saturated");
      filter.appendChild(sat);

      const contrast = document.createElementNS(svgNS,"feComponentTransfer");
      contrast.setAttribute("in","saturated");
      contrast.setAttribute("result","contrasted");
      for(const c of ['R','G','B']){
        const func = document.createElementNS(svgNS,"feFunc"+c);
        func.setAttribute("type","linear");
        func.setAttribute("slope",(1 + y*0.05).toFixed(3));
        contrast.appendChild(func);
      }
      filter.appendChild(contrast);

      const hue = document.createElementNS(svgNS,"feColorMatrix");
      hue.setAttribute("in","contrasted");
      hue.setAttribute("type","hueRotate");
      hue.setAttribute("values",(z*10).toFixed(1));
      hue.setAttribute("result","hued");
      filter.appendChild(hue);

      const bright = document.createElementNS(svgNS,"feComponentTransfer");
      bright.setAttribute("in","hued");
      bright.setAttribute("result","brightened");
      for(const c of ['R','G','B']){
        const func = document.createElementNS(svgNS,"feFunc"+c);
        func.setAttribute("type","linear");
        func.setAttribute("slope",brightness.toFixed(3));
        bright.appendChild(func);
      }
      filter.appendChild(bright);

      const colorMatrix = document.createElementNS(svgNS,"feColorMatrix");
      colorMatrix.setAttribute("in","noise");
      colorMatrix.setAttribute("type","saturate");
      colorMatrix.setAttribute("values","0");
      colorMatrix.setAttribute("result","desaturatedNoise");
      filter.appendChild(colorMatrix);

      const componentTransfer = document.createElementNS(svgNS,"feComponentTransfer");
      componentTransfer.setAttribute("in","desaturatedNoise");
      componentTransfer.setAttribute("result","theNoise");
      const funcA = document.createElementNS(svgNS,"feFuncA");
      funcA.setAttribute("type","table");
      funcA.setAttribute("tableValues","0 0 0.15 0");
      componentTransfer.appendChild(funcA);
      filter.appendChild(componentTransfer);

      const blend = document.createElementNS(svgNS,"feBlend");
      blend.setAttribute("in","brightened");
      blend.setAttribute("in2","theNoise");
      blend.setAttribute("mode","multiply");
      filter.appendChild(blend);

      defs.appendChild(filter);
      return filterId;
    }

    function renderBlock(x, y, z, color) {
      const sx = (originX + x*(tileW*xScale) - y*(tileW*yScale));
      const sy = (originY + x*(tileH*xScale) + y*(tileH*yScale) - z*levelHeight);

      const g = document.createElementNS(svgNS,"g");
      g.setAttribute("transform", `translate(${sx},${sy})`);
      g.setAttribute("data-block", "true");
      g.dataset.x = x;
      g.dataset.y = y;
      g.dataset.z = z;

      const w = tileW * xScale;
      const h = tileH * yScale;
      const vHeight = levelHeight;

      // Top face
      const top = document.createElementNS(svgNS,"polygon");
      top.setAttribute("points",`${w} 0, ${w*2} ${h}, ${w} ${h*2}, 0 ${h}`);
      top.setAttribute("class","face");
      const fTop = createFaceFilter(x,y,z,1.15,color);
      top.setAttribute("filter",`url(#${fTop})`);
      top.dataset.face = "top";
      g.appendChild(top);

      // Left face (lighter one going down-left)
      const left = document.createElementNS(svgNS,"polygon");
      left.setAttribute("points",`0 ${h}, ${w} ${h*2}, ${w} ${h*2+vHeight}, 0 ${h+vHeight}`);
      left.setAttribute("class","face");
      const fLeft = createFaceFilter(x,y,z,0.95,color);
      left.setAttribute("filter",`url(#${fLeft})`);
      left.dataset.face = "left";
      g.appendChild(left);

      // Right face (darker one going down-right)
      const right = document.createElementNS(svgNS,"polygon");
      right.setAttribute("points",`${w*2} ${h}, ${w} ${h*2}, ${w} ${h*2+vHeight}, ${w*2} ${h+vHeight}`);
      right.setAttribute("class","face");
      const fRight = createFaceFilter(x,y,z,0.8,color);
      right.setAttribute("filter",`url(#${fRight})`);
      right.dataset.face = "right";
      g.appendChild(right);

      // Click handler based on current mode and face
      const clickHandler = (e) => {
        e.stopPropagation();
        const face = e.target.dataset.face;
        
        if (isAddMode) {
          let placed = false;
          
          // Place based on which face was clicked
          if (face === "top") {
            // Top face clicked - place above (z+1)
            if (z + 1 < size && !blockData[z + 1][y][x].exists) {
              blockData[z + 1][y][x] = { exists: true, color: colorInput.value };
              placed = true;
            }
          } else if (face === "left") {
            // Left face (lighter, going down-left) - place away from viewer (+y)
            if (y + 1 < size && !blockData[z][y + 1][x].exists) {
              blockData[z][y + 1][x] = { exists: true, color: colorInput.value };
              placed = true;
            }
          } else if (face === "right") {
            // Right face (darker, going down-right) - place to the right (+x)
            if (x + 1 < size && !blockData[z][y][x + 1].exists) {
              blockData[z][y][x + 1] = { exists: true, color: colorInput.value };
              placed = true;
            }
          }
          
          // Fallback: if face placement failed, try other adjacent spaces
          if (!placed) {
            // Try placing on top first
            if (z + 1 < size && !blockData[z + 1][y][x].exists) {
              blockData[z + 1][y][x] = { exists: true, color: colorInput.value };
              placed = true;
            }
            // Try +x direction
            else if (x + 1 < size && !blockData[z][y][x + 1].exists) {
              blockData[z][y][x + 1] = { exists: true, color: colorInput.value };
              placed = true;
            }
            // Try -y direction
            else if (y - 1 >= 0 && !blockData[z][y - 1][x].exists) {
              blockData[z][y - 1][x] = { exists: true, color: colorInput.value };
              placed = true;
            }
            // Try -x direction
            else if (x - 1 >= 0 && !blockData[z][y][x - 1].exists) {
              blockData[z][y][x - 1] = { exists: true, color: colorInput.value };
              placed = true;
            }
            // Try +y direction
            else if (y + 1 < size && !blockData[z][y + 1][x].exists) {
              blockData[z][y + 1][x] = { exists: true, color: colorInput.value };
              placed = true;
            }
          }
          
          if (placed) {
            renderAllBlocks();
            saveState();
          }
        } else {
          // Remove block
          blockData[z][y][x] = { exists: false, color: null };
          renderAllBlocks();
          saveState();
        }
      };

      top.addEventListener("click", clickHandler);
      left.addEventListener("click", clickHandler);
      right.addEventListener("click", clickHandler);

      svg.appendChild(g);
    }

    // Initialize grid
    loadState();
    renderAllBlocks();
  /*]]>*/</script>

</svg>
